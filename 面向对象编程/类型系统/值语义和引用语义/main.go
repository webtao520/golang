package main 

import (
	"fmt"
)

/*
	值语义和引用语义的差别在于赋值，比如下面的例子：
	b = a 
	b.Modify() 
	如果b的修改不会影响a的值，那么此类型属于值类型。如果会影响a的值，那么此类型是引用
	类型。

	Go语言中的大多数类型都基于值语义，包括：
	 基本类型，如byte/uint8、int、bool、float32、float64和string等；
	 复合类型，如数组（array）、结构体（struct）和指针（pointer）等。

	Go语言中类型的值语义表现得非常彻底。我们之所以这么说，是因为数组。
	如果读者之前学过C语言，就会知道C语言中的数组比较特别。通过函数传递一个数组的时
	候基于引用语义，但是在结构体中定义数组变量的时候基于值语义（表现在为结构体赋值的时候，
	该数组会被完整地复制）。

*/

func main (){
	//Go语言中的数组和基本类型没有区别，是很纯粹的值类型，例如：
	var a = [3]int{1,2,3}
	// var b =a 
	// b[1]++
	// fmt.Println(a,b)
	/*
	该程序的运行结果如下：
	[1 2 3] [1 3 3]。
	这表明b=a赋值语句是数组内容的完整复制。要想表达引用，需要用指针：
	*/

	var b=&a 
	b[1]++ 
   fmt.Println(a, *b)
   fmt.Printf("%T",b) // *[3]int 数组指针
   /*
			该程序的运行结果如下：
					[1 3 3] [1 3 3]
			这表明b=&a赋值语句是数组内容的引用。变量b的类型不是[3]int，而是*[3]int类型。
			Go语言中有4个类型比较特别，看起来像引用类型，如下所示。

			 数组切片：指向数组（array）的一个区间。
			 map：极其常见的数据结构，提供键值查询能力。
			 channel：执行体（goroutine）间的通信设施。
			 接口（interface）：对一组满足某个契约的类型的抽象。

			但是这并不影响我们将Go语言类型看做值语义。下面我们来看看这4个类型。
			数组切片本质上是一个区间，你可以大致将[]T表示为：
			type slice struct { 
				first *T 
				len int 
				cap int 
			} 
			因为数组切片内部是指向数组的指针，所以可以改变所指向的数组元素并不奇怪。数组切片
			类型本身的赋值仍然是值语义。
			map本质上是一个字典指针，你可以大致将map[K]V表示为：
			type Map_K_V struct { 
				// ... 
			} 

			type map[K]V struct { 
				impl *Map_K_V 
			} 
			基于指针，我们完全可以自定义一个引用类型，如：

			type IntegerRef struct { 
				impl *int
			} 

			channel和map类似，本质上是一个指针。将它们设计为引用类型而不是统一的值类型的原因
			是，完整复制一个channel或map并不是常规需求。
			同样，接口具备引用语义，是因为内部维持了两个指针，示意为：

			type interface struct { 
				data *void 
				itab *Itab 
			} 

			接口在Go语言中的地位非常重要。关于接口的内部实现细节，在后面的高阶话题中我们再
			细细剖析。
   */
    
}